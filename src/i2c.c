//----------------------------------------------------------------------------
// Файл i2c.c
// работа с шиной I2c
//----------------------------------------------------------------------------


#include	"global.h"


#define MLX90640_REFRESH_RATE   (8) // 2Hz (0.5-64 available)
#define MLX90640_REFRESH_VALUE  MLX_CR1_REF_RATE_8_HZ  // accordity to refresh rate

#define MLX90640_START_DELAY    (80 + 2000 / MLX90640_REFRESH_RATE)  // 
#define MLX90640_WAIT_DELAY     (1600 / MLX90640_REFRESH_RATE)  // 
#define MLX90640_ERROR_DELAY    (4000 / MLX90640_REFRESH_RATE)  // 

typedef enum
{
  PIR_INIT_DELAY = 0,
  PIR_INIT,
  PIR_READ_SBP0,
  PIR_CALCULATE_SBP0,
  PIR_READ_SBP1,
  PIR_CALCULATE_SBP1
} pir_states;



#define TA_SHIFT  8.0f //the default shift for a MLX90640 device in open air

#ifdef  SIMULATION

const static u16 sample_eeprom_data[832] =
{
0x00AE, 0x499A, 0x0000, 0x2061, 0x0005, 0x0320, 0x03E0, 0x1710, // 0x0000
0xA224, 0x0185, 0x0499, 0x0000, 0x1901, 0x0000, 0x0000, 0xB533, // 0x0010
0x4210, 0xFFC2, 0x0202, 0x0202, 0xF202, 0xF1F2, 0xD1E1, 0xAFC0, // 0x0020
0xFF00, 0xF002, 0xF103, 0xE103, 0xE1F5, 0xD1E4, 0xC1D5, 0x91C2, // 0x0030
0x8895, 0x30D9, 0xEDCB, 0x110F, 0x3322, 0x2233, 0x0011, 0xCCEE, // 0x0040
0xFFED, 0x1100, 0x2222, 0x3333, 0x2233, 0x0022, 0xDEF0, 0x9ACC, // 0x0050
0x15CC, 0x2FA4, 0x2555, 0x9C78, 0x7666, 0x01C8, 0x3B38, 0x3534, // 0x0060
0x2452, 0x0463, 0x13BB, 0x0623, 0xEC00, 0x9797, 0x9797, 0x2AFB, // 0x0070
0x00AE, 0xFBE0, 0x1B70, 0xF3BE, 0x000E, 0xF86E, 0x1B7E, 0xF3CE, // 0x0080
0xFFCE, 0xF41E, 0x102E, 0xEC0E, 0xFFDE, 0xEC3E, 0x139E, 0xEF9E, // 0x0090
0xFB9E, 0xF77E, 0x13E0, 0xE7EE, 0xF7AE, 0xF750, 0x0C30, 0xEBEE, // 0x00A0
0xF730, 0xF010, 0x0B50, 0xE430, 0xF420, 0xF370, 0x07C0, 0xE450, // 0x00B0
0x0470, 0xFBCE, 0xFF5C, 0x0F90, 0x07D0, 0xFC3E, 0xFF6C, 0x0F90, // 0x00C0
0x03A0, 0xFC0E, 0xF40C, 0x0BF0, 0x03A0, 0xF41E, 0xF78C, 0x0B70, // 0x00D0
0xFF72, 0xFF6E, 0xF7DE, 0x07C0, 0xFFA2, 0x0330, 0xF42E, 0x0BC0, // 0x00E0
0xFF22, 0xFC00, 0xF75E, 0x0410, 0x0022, 0x0350, 0xF3A0, 0x0832, // 0x00F0
0x04DE, 0xFBF0, 0x1BCE, 0xF00E, 0xFC5E, 0xFC80, 0x1BF0, 0xF02E, // 0x0100
0x0002, 0xF81E, 0x142E, 0xEC9E, 0x07DE, 0xF09E, 0x17CE, 0xF3AE, // 0x0110
0xFFC0, 0xFBB0, 0x1080, 0xEBFE, 0xFFE0, 0xFF90, 0x1460, 0xE4AE, // 0x0120
0xFBC0, 0xF840, 0x0FE0, 0xE860, 0xF8C0, 0xF400, 0x0842, 0xE4B0, // 0x0130
0x0890, 0x03BE, 0xFF9C, 0x0FD0, 0x0020, 0x0450, 0xFFCC, 0x0FE0, // 0x0140
0x07D0, 0x03FE, 0xFBEE, 0x0C60, 0x0B80, 0xF86E, 0xFB8E, 0x1370, // 0x0150
0x0782, 0x038E, 0xF85E, 0x0FC2, 0x07C2, 0x037E, 0xF84E, 0x0880, // 0x0160
0x0392, 0x0420, 0xF7CE, 0x0C42, 0xFCB2, 0xFFE0, 0xF020, 0x0490, // 0x0170
0x107E, 0x03D0, 0x1F90, 0xFBCE, 0x089E, 0x0080, 0x1820, 0xF40E, // 0x0180
0x0800, 0xFC30, 0x141E, 0xF06E, 0x0400, 0xFFA0, 0x17CE, 0xF7B0, // 0x0190
0x07D0, 0xFFB0, 0x1830, 0xF3FE, 0x0002, 0xFFE0, 0x14D0, 0xECB0, // 0x01A0
0xFBE2, 0xFCB0, 0x13B0, 0xECA0, 0xF8DE, 0xF432, 0x0832, 0xE8D0, // 0x01B0
0x1420, 0xFF8E, 0xFF6E, 0x1380, 0x0840, 0x005E, 0xFBEC, 0x0FB0, // 0x01C0
0x0BB2, 0xFFFE, 0xFBDE, 0x0820, 0x0BC0, 0x0360, 0xFB8C, 0x0F70, // 0x01D0
0x0794, 0x036E, 0xFBFE, 0x0FA0, 0x0BC4, 0x0390, 0xF89E, 0x0C72, // 0x01E0
0xFFB2, 0xFC70, 0xFB7E, 0x0470, 0xFCB0, 0xFFF0, 0xF3F0, 0x04A0, // 0x01F0
0x049E, 0x03B0, 0x1F90, 0xF7D0, 0x042E, 0x0070, 0x1F70, 0xFBBE, // 0x0200
0x0F00, 0x03B0, 0x142E, 0xF01E, 0x07B0, 0xFFB0, 0x1B60, 0xF37E, // 0x0210
0xFBD0, 0xFF90, 0x1410, 0xF3C0, 0xFC00, 0x0370, 0x1482, 0xF030, // 0x0220
0xF800, 0xFC50, 0x13C2, 0xF050, 0x0070, 0xF812, 0x0C02, 0xEC80, // 0x0230
0x00D0, 0xFBFE, 0xFBCC, 0x0810, 0xFC60, 0xFCB0, 0xFBCE, 0x0FE0, // 0x0240
0x0B40, 0xFFFE, 0xF05C, 0x0840, 0x07D0, 0xFFD0, 0xF79E, 0x0FB0, // 0x0250
0xF802, 0xFFD0, 0xF44E, 0x0BF0, 0xFC32, 0x07A0, 0xF4BE, 0x0C60, // 0x0260
0xF822, 0x0080, 0xF01E, 0x0892, 0x00B4, 0xF850, 0xF040, 0x04B2, // 0x0270
0x085E, 0x0782, 0x1F70, 0xFBEE, 0x001E, 0x0420, 0x1F80, 0xFBB0, // 0x0280
0x03B0, 0x0390, 0x17F0, 0xF04E, 0x0770, 0xFFE0, 0x1B40, 0xF76E, // 0x0290
0xFFC0, 0xFFB0, 0x17E0, 0xEC1E, 0x03A0, 0x03A0, 0x10C0, 0xEC60, // 0x02A0
0xFBC2, 0xFC80, 0x0C00, 0xEC60, 0x0050, 0xF800, 0x0802, 0xEC90, // 0x02B0
0x0080, 0xF7B0, 0xF7AE, 0x0410, 0xFC32, 0xFC50, 0xF7BE, 0x07F0, // 0x02C0
0xFFD2, 0xFBC0, 0xF02E, 0x0460, 0x0382, 0xF410, 0xF36E, 0x0BA0, // 0x02D0
0xFBF2, 0xFBC0, 0xF01C, 0x0440, 0xFFE2, 0xFBE0, 0xF0EE, 0x08A2, // 0x02E0
0xF804, 0xFCB0, 0xEC3E, 0x04A2, 0x0082, 0xF830, 0xE830, 0x04B2, // 0x02F0
0x13F0, 0x0380, 0x1F40, 0xFBB0, 0x0F90, 0x0420, 0x17A0, 0xF7AE, // 0x0300
0x0F40, 0xFFE2, 0x13AE, 0xF03E, 0x0F12, 0xFF60, 0x0F50, 0xF340, // 0x0310
0x0362, 0xFF30, 0x1760, 0xEFD0, 0x0762, 0x0360, 0x1072, 0xEC50, // 0x0320
0xF7B2, 0xF852, 0x07B0, 0xE480, 0xF820, 0xF7C2, 0x03C2, 0xE490, // 0x0330
0x1422, 0x03AE, 0x036E, 0x13C2, 0x13B2, 0x0440, 0xFFCE, 0x13D2, // 0x0340
0x1362, 0x0002, 0xFBDE, 0x0C40, 0x1732, 0x0390, 0xFF8E, 0x1760, // 0x0350
0x0B82, 0x0750, 0x039E, 0x1000, 0x0F82, 0x0B80, 0xFCAE, 0x1080, // 0x0360
0x0BD4, 0x0470, 0xFBCE, 0x0C92, 0x0832, 0x07E0, 0xF7FE, 0x0CA2, // 0x0370
0x0010, 0x0380, 0x13D0, 0xF7A0, 0xFFBE, 0x0052, 0x1380, 0xF770, // 0x0380
0xFF70, 0xFFA0, 0x0FC0, 0xF3BE, 0x0340, 0xFF60, 0x0FC0, 0xF370, // 0x0390
0xFB30, 0xFB80, 0x0C10, 0xE40E, 0xFBA0, 0xFBB0, 0x0C42, 0xE860, // 0x03A0
0xFB92, 0xF4A2, 0x0B82, 0xE850, 0xF832, 0xFBA2, 0x0002, 0xE470, // 0x03B0
0x0022, 0xF7A0, 0xEFFE, 0x0BC0, 0x03D2, 0xF860, 0xF79E, 0x0F92, // 0x03C0
0x0390, 0xFFB0, 0xF3FE, 0x0FC0, 0x0762, 0xFF70, 0xEFFE, 0x1380, // 0x03D0
0x0362, 0xFFB0, 0xF42E, 0x0810, 0x07A2, 0x07C0, 0xF87E, 0x0C82, // 0x03E0
0x0B94, 0x0490, 0xFB90, 0x1062, 0x0842, 0x07B0, 0xEC10, 0x0C82, // 0x03F0
0x0850, 0x13E2, 0x2360, 0x0420, 0x0460, 0x10B0, 0x1FB0, 0x03E0, // 0x0400
0x0B80, 0x0BF0, 0x1430, 0xFC00, 0x0F90, 0x0BC2, 0x1BA0, 0xFFC0, // 0x0410
0x07C2, 0x0B82, 0x1BF0, 0xF44E, 0x0BB2, 0x0FD2, 0x14C2, 0xF8A0, // 0x0420
0x0792, 0x0852, 0x13E2, 0xF850, 0x00A0, 0x0032, 0x0C22, 0xF0D0, // 0x0430
0xF452, 0xEFE0, 0xEF7E, 0xFC32, 0xF072, 0xF4C0, 0xEBCE, 0x03F0, // 0x0440
0xFBA2, 0xF400, 0xE45E, 0x0410, 0xFFA2, 0xF7D0, 0xEBBE, 0x0BD0, // 0x0450
0xFBC2, 0xFB80, 0xF00E, 0x0050, 0x03D2, 0x03D0, 0xF0E0, 0x0CA0, // 0x0460
0x0384, 0x0440, 0xF3EE, 0x0C52, 0x00A2, 0x0030, 0xEC20, 0x04C0, // 0x0470
0x1022, 0x0FD2, 0x1F80, 0x03F0, 0x0830, 0x0C82, 0x17E0, 0xFFB0, // 0x0480
0x0410, 0x0432, 0x0870, 0xF48E, 0x0BD0, 0x07B2, 0x0F90, 0xFBB0, // 0x0490
0xFFF0, 0x07A2, 0x1410, 0xF410, 0x0022, 0x0BC2, 0x0CE0, 0xF850, // 0x04A0
0xFFB2, 0x0490, 0x0BC0, 0xECC0, 0xFC70, 0x0012, 0x0400, 0xF0B2, // 0x04B0
0x0402, 0xF7D0, 0xF37E, 0x0BF2, 0x0022, 0xFC90, 0xEFFE, 0x0FC2, // 0x04C0
0xFC12, 0xF84E, 0xE87E, 0x0480, 0x07E2, 0xFFB0, 0xF7AE, 0x0FC0, // 0x04D0
0x0002, 0x07A0, 0xF81E, 0x1002, 0x0422, 0x0FD0, 0xF8CE, 0x1842, // 0x04E0
0x07A4, 0x0880, 0xFBB0, 0x0CB0, 0x0C62, 0x0BF0, 0xFBF0, 0x10A0, // 0x04F0
0xF030, 0x07D2, 0x0BE0, 0xF800, 0xECA0, 0x0482, 0x0830, 0xFBE0, // 0x0500
0xF040, 0xFC80, 0x0810, 0xF030, 0xF410, 0xF830, 0x0BA0, 0xF7A0, // 0x0510
0xF3D2, 0xFFF2, 0x0840, 0xEFF0, 0xF400, 0x03B2, 0x0872, 0xF030, // 0x0520
0xEFB2, 0x0042, 0x03B2, 0xEC40, 0xFFE0, 0xFFE2, 0x0012, 0xF420, // 0x0530
0xF422, 0xF7B0, 0xE7CE, 0x0BD2, 0xF080, 0x0070, 0xEC2E, 0x0FE2, // 0x0540
0xF850, 0x0070, 0xF00E, 0x0C42, 0x0020, 0x0030, 0xF7AE, 0x17B2, // 0x0550
0x03D2, 0x0400, 0xF84E, 0x17F0, 0x0BE2, 0x13A0, 0xFC4E, 0x1820, // 0x0560
0x0792, 0x1020, 0xFB9E, 0x1C10, 0x1BC2, 0x13C0, 0xFBE0, 0x2002, // 0x0570
0xF040, 0x13A2, 0x0F80, 0xFC30, 0xF46E, 0x0CC2, 0x17B2, 0x0010, // 0x0580
0xFC10, 0x0872, 0x1000, 0xF8B0, 0x07BE, 0x0BE2, 0x13B0, 0xFFE0, // 0x0590
0xF410, 0x0450, 0x0C70, 0xF420, 0x03C0, 0x0F82, 0x1060, 0xFFE0, // 0x05A0
0xFB70, 0x13D2, 0x0F90, 0xF820, 0xFC40, 0x0FA2, 0x0BE2, 0xFC60, // 0x05B0
0xF012, 0xFB80, 0xEB5E, 0x0802, 0xF420, 0x0090, 0xF78E, 0x13E2, // 0x05C0
0xFC02, 0x0060, 0xF40E, 0x1090, 0x0F90, 0x0BD0, 0xFBAE, 0x1FD2, // 0x05D0
0x0002, 0x0820, 0xF85E, 0x1800, 0x0F82, 0x1B60, 0xFC3E, 0x23C2, // 0x05E0
0x0B42, 0x1BA0, 0xFF7E, 0x27E0, 0x1012, 0x1B70, 0xFFC0, 0x2040, // 0x05F0
0xFC70, 0x1BA2, 0x0FA0, 0x0BA0, 0x0002, 0x1432, 0x0FE0, 0x0010, // 0x0600
0xF83E, 0x13E0, 0x085E, 0x07E0, 0x005E, 0x0842, 0x0FEE, 0x03D0, // 0x0610
0xFC20, 0x0FE2, 0x1400, 0x0780, 0x0B90, 0x1772, 0x1410, 0x07B0, // 0x0620
0xFB10, 0x17F2, 0x0B20, 0x03F0, 0xFC1E, 0x17B2, 0x07CE, 0x0830, // 0x0630
0xE050, 0xEF80, 0xD38E, 0x0382, 0xEBE0, 0xF810, 0xDFBE, 0x07D0, // 0x0640
0xEC10, 0xFFC0, 0xE01E, 0x0BB0, 0xF820, 0xF810, 0xEBBE, 0x0BA0, // 0x0650
0xFBF0, 0x07A0, 0xF3EE, 0x1B50, 0x0752, 0x0F30, 0xF7EE, 0x1B80, // 0x0660
0x02F2, 0x0FD0, 0xF70E, 0x13C0, 0x0BE0, 0x1390, 0xF79E, 0x1C00  // 0x0670
};

const static u16 sample_frame_0[834] =
{
0xFFB3, 0xFFAC, 0xFFB4, 0xFFAA, 0xFFB3, 0xFFAC, 0xFFB6, 0xFFA9, // 0x0000 
0xFFB2, 0xFFA8, 0xFFB4, 0xFFA6, 0xFFB1, 0xFFA5, 0xFFB4, 0xFFA2, // 0x0010 
0xFFB4, 0xFFA5, 0xFFB4, 0xFFA4, 0xFFB6, 0xFFA7, 0xFFB5, 0xFFA4, // 0x0020 
0xFFBA, 0xFFA6, 0xFFB8, 0xFFA5, 0xFFB6, 0xFFAA, 0xFFBD, 0xFFA4, // 0x0030 
0xFFA9, 0xFFA8, 0xFFA6, 0xFFA8, 0xFFA9, 0xFFA6, 0xFFA6, 0xFFA5, // 0x0040 
0xFFAA, 0xFFA2, 0xFFA5, 0xFFA2, 0xFFA9, 0xFF9F, 0xFFA5, 0xFFA1, // 0x0050 
0xFFAD, 0xFFA0, 0xFFA6, 0xFFA2, 0xFFAB, 0xFFA3, 0xFFA8, 0xFFA4, // 0x0060 
0xFFB2, 0xFFA2, 0xFFAB, 0xFFA3, 0xFFB0, 0xFFA4, 0xFFAF, 0xFFA3, // 0x0070 
0xFFB2, 0xFFAC, 0xFFB4, 0xFFAB, 0xFFB1, 0xFFAC, 0xFFB1, 0xFFA8, // 0x0080 
0xFFB1, 0xFFA9, 0xFFB3, 0xFFA5, 0xFFB2, 0xFFA5, 0xFFB1, 0xFFA3, // 0x0090 
0xFFB5, 0xFFA5, 0xFFB1, 0xFFA3, 0xFFB6, 0xFFA7, 0xFFB5, 0xFFA2, // 0x00A0 
0xFFB8, 0xFFA7, 0xFFB7, 0xFFA3, 0xFFB6, 0xFFA8, 0xFFB9, 0xFFA2, // 0x00B0 
0xFFA7, 0xFFA7, 0xFFA4, 0xFFA7, 0xFFA9, 0xFFA5, 0xFFA4, 0xFFA6, // 0x00C0 
0xFFA8, 0xFFA3, 0xFFA4, 0xFFA2, 0xFFAC, 0xFF9F, 0xFFA2, 0xFFA3, // 0x00D0 
0xFFAD, 0xFFA0, 0xFFA4, 0xFFA2, 0xFFAC, 0xFFA2, 0xFFA8, 0xFFA1, // 0x00E0 
0xFFB1, 0xFFA3, 0xFFA8, 0xFFA3, 0xFFAD, 0xFFA1, 0xFFAC, 0xFFA1, // 0x00F0 
0xFFB3, 0xFFAD, 0xFFB5, 0xFFA9, 0xFFB2, 0xFFAB, 0xFFB2, 0xFFA8, // 0x0100 
0xFFB4, 0xFFA9, 0xFFB1, 0xFFA4, 0xFFB1, 0xFFA6, 0xFFB3, 0xFFA2, // 0x0110 
0xFFB5, 0xFFA7, 0xFFB2, 0xFFA3, 0xFFB2, 0xFFA5, 0xFFB4, 0xFFA2, // 0x0120 
0xFFB6, 0xFFA5, 0xFFB8, 0xFFA5, 0xFFB4, 0xFFA7, 0xFFB9, 0xFFA0, // 0x0130 
0xFFAA, 0xFFA5, 0xFFA4, 0xFFA6, 0xFFAA, 0xFFA4, 0xFFA2, 0xFFA4, // 0x0140 
0xFFA9, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFAA, 0xFFA1, 0xFFA3, 0xFFA0, // 0x0150 
0xFFAD, 0xFF9F, 0xFFA4, 0xFFA3, 0xFFAB, 0xFFA0, 0xFFA3, 0xFFA1, // 0x0160 
0xFFAD, 0xFF9E, 0xFFA9, 0xFFA1, 0xFFAB, 0xFFA0, 0xFFAA, 0xFF9D, // 0x0170 
0xFFB0, 0xFFAD, 0xFFB2, 0xFFAA, 0xFFB2, 0xFFAB, 0xFFB3, 0xFFA9, // 0x0180 
0xFFB8, 0xFFAA, 0xFFB6, 0xFFA4, 0xFFB2, 0xFFA6, 0xFFB1, 0xFFA4, // 0x0190 
0xFFB2, 0xFFA4, 0xFFB2, 0xFFA4, 0xFFB2, 0xFFA7, 0xFFB5, 0xFFA4, // 0x01A0 
0xFFB2, 0xFFA5, 0xFFB4, 0xFFA2, 0xFFB4, 0xFFA6, 0xFFB9, 0xFFA2, // 0x01B0 
0xFFA5, 0xFFA4, 0xFFA1, 0xFFA4, 0xFFA6, 0xFFA0, 0xFFA1, 0xFFA3, // 0x01C0 
0xFFA8, 0xFFA7, 0xFFA1, 0xFFAA, 0xFFA6, 0xFFA1, 0xFFA1, 0xFFA1, // 0x01D0 
0xFFA8, 0xFF9D, 0xFFA2, 0xFF9F, 0xFFA8, 0xFF9F, 0xFFA2, 0xFF9F, // 0x01E0 
0xFFAB, 0xFF9E, 0xFFA4, 0xFFA0, 0xFFAB, 0xFF9F, 0xFFA8, 0xFF9B, // 0x01F0 
0xFFAF, 0xFFAE, 0xFFB3, 0xFFA9, 0xFFAF, 0xFFAB, 0xFFB4, 0xFFA8, // 0x0200 
0xFFBB, 0xFFAA, 0xFFC6, 0xFFA6, 0xFFC0, 0xFFA8, 0xFFB6, 0xFFA2, // 0x0210 
0xFFB0, 0xFFA5, 0xFFB1, 0xFFA2, 0xFFB3, 0xFFA6, 0xFFB2, 0xFFA2, // 0x0220 
0xFFB4, 0xFFA2, 0xFFB4, 0xFFA2, 0xFFB4, 0xFFA6, 0xFFB7, 0xFFA1, // 0x0230 
0xFFA3, 0xFFA2, 0xFF9F, 0xFFA1, 0xFFA5, 0xFFA2, 0xFFA2, 0xFFA4, // 0x0240 
0xFFAA, 0xFFB2, 0xFFA4, 0xFFB4, 0xFFA8, 0xFFAD, 0xFFA1, 0xFFA6, // 0x0250 
0xFFA8, 0xFF9D, 0xFFA2, 0xFF9D, 0xFFAB, 0xFF9D, 0xFFA3, 0xFF9F, // 0x0260 
0xFFAD, 0xFF9C, 0xFFA3, 0xFF9F, 0xFFAB, 0xFF9D, 0xFFA6, 0xFF9C, // 0x0270 
0xFFB3, 0xFFAD, 0xFFB3, 0xFFA9, 0xFFB4, 0xFFAC, 0xFFB5, 0xFFA9, // 0x0280 
0xFFC8, 0xFFAE, 0xFFC8, 0xFFAB, 0xFFC9, 0xFFAE, 0xFFC2, 0xFFA6, // 0x0290 
0xFFBD, 0xFFA9, 0xFFB5, 0xFFA8, 0xFFB2, 0xFFAC, 0xFFB0, 0xFFA4, // 0x02A0 
0xFFB3, 0xFFA4, 0xFFB2, 0xFFA1, 0xFFB2, 0xFFA4, 0xFFB4, 0xFF9C, // 0x02B0 
0xFFA4, 0xFFA1, 0xFF9F, 0xFFA2, 0xFFA7, 0xFFA1, 0xFFA2, 0xFFAA, // 0x02C0 
0xFFAD, 0xFFB7, 0xFFA7, 0xFFB8, 0xFFAD, 0xFFB5, 0xFFA3, 0xFFB1, // 0x02D0 
0xFFAF, 0xFFA8, 0xFFAA, 0xFFA0, 0xFFB2, 0xFF9B, 0xFFA5, 0xFF9D, // 0x02E0 
0xFFAC, 0xFF9A, 0xFFA4, 0xFF9D, 0xFFAB, 0xFF9C, 0xFFA5, 0xFF9A, // 0x02F0 
0xFFAE, 0xFFAD, 0xFFAD, 0xFFA8, 0xFFB1, 0xFFAD, 0xFFBB, 0xFFAE, // 0x0300 
0xFFCB, 0xFFB2, 0xFFCE, 0xFFAE, 0xFFCB, 0xFFB0, 0xFFC5, 0xFFAB, // 0x0310 
0xFFC6, 0xFFB2, 0xFFBD, 0xFFB0, 0xFFB2, 0xFFB1, 0xFFB0, 0xFFA8, // 0x0320 
0xFFB3, 0xFFAA, 0xFFB1, 0xFFA4, 0xFFB1, 0xFFA5, 0xFFB4, 0xFF9D, // 0x0330 
0xFF9F, 0xFF9E, 0xFF98, 0xFF9F, 0xFFA3, 0xFFA0, 0xFFA2, 0xFFB3, // 0x0340 
0xFFAC, 0xFFBB, 0xFFA7, 0xFFBF, 0xFFAE, 0xFFB7, 0xFFA5, 0xFFB3, // 0x0350 
0xFFB4, 0xFFB0, 0xFFAE, 0xFFA6, 0xFFB6, 0xFF9B, 0xFFAB, 0xFF99, // 0x0360 
0xFFB4, 0xFF9A, 0xFFA7, 0xFF9D, 0xFFAC, 0xFF9D, 0xFFA5, 0xFF9A, // 0x0370 
0xFFAC, 0xFFAD, 0xFFB0, 0xFFA8, 0xFFB1, 0xFFAD, 0xFFC3, 0xFFAF, // 0x0380 
0xFFCA, 0xFFB3, 0xFFCD, 0xFFAD, 0xFFCA, 0xFFB0, 0xFFC8, 0xFFAD, // 0x0390 
0xFFC6, 0xFFB8, 0xFFB9, 0xFFB1, 0xFFB2, 0xFFB5, 0xFFAF, 0xFFAD, // 0x03A0 
0xFFB3, 0xFFAF, 0xFFB0, 0xFFA9, 0xFFB0, 0xFFA6, 0xFFB4, 0xFF9D, // 0x03B0 
0xFF9E, 0xFF9C, 0xFF9C, 0xFF9F, 0xFFA1, 0xFFA4, 0xFFA0, 0xFFB3, // 0x03C0 
0xFFAB, 0xFFB5, 0xFFA4, 0xFFB9, 0xFFAC, 0xFFB3, 0xFFA7, 0xFFB2, // 0x03D0 
0xFFB5, 0xFFAF, 0xFFB1, 0xFF9D, 0xFFB7, 0xFF9B, 0xFFAD, 0xFF9A, // 0x03E0 
0xFFB6, 0xFF9A, 0xFFA8, 0xFF9C, 0xFFAA, 0xFF9B, 0xFFA5, 0xFF9A, // 0x03F0 
0xFFAE, 0xFFAC, 0xFFB0, 0xFFAB, 0xFFB6, 0xFFAE, 0xFFC0, 0xFFAD, // 0x0400 
0xFFC3, 0xFFB0, 0xFFC2, 0xFFAB, 0xFFC4, 0xFFB0, 0xFFC2, 0xFFB0, // 0x0410 
0xFFC4, 0xFFB8, 0xFFB2, 0xFFB3, 0xFFAE, 0xFFB4, 0xFFAE, 0xFFAF, // 0x0420 
0xFFB0, 0xFFAF, 0xFFAF, 0xFFA5, 0xFFB2, 0xFFA4, 0xFFB3, 0xFF9D, // 0x0430 
0xFF9E, 0xFF9A, 0xFF9A, 0xFF9F, 0xFFA1, 0xFFA4, 0xFF9D, 0xFFAF, // 0x0440 
0xFFA7, 0xFFAC, 0xFF9F, 0xFFAD, 0xFFAA, 0xFFB0, 0xFFA7, 0xFFAF, // 0x0450 
0xFFB5, 0xFFA6, 0xFFAF, 0xFF9A, 0xFFB5, 0xFF98, 0xFFAA, 0xFF9B, // 0x0460 
0xFFB3, 0xFF99, 0xFFA5, 0xFF9A, 0xFFAA, 0xFF9F, 0xFFA5, 0xFF9A, // 0x0470 
0xFFA7, 0xFFAC, 0xFFAA, 0xFFA8, 0xFFAA, 0xFFAD, 0xFFB0, 0xFFAB, // 0x0480 
0xFFB9, 0xFFAD, 0xFFBF, 0xFFAB, 0xFFBD, 0xFFAF, 0xFFC0, 0xFFB0, // 0x0490 
0xFFBA, 0xFFB4, 0xFFAE, 0xFFAF, 0xFFAC, 0xFFB0, 0xFFAC, 0xFFAC, // 0x04A0 
0xFFB0, 0xFFAE, 0xFFB0, 0xFFA6, 0xFFBB, 0xFFA5, 0xFFBC, 0xFFA0, // 0x04B0 
0xFF96, 0xFF96, 0xFF92, 0xFF99, 0xFF99, 0xFF98, 0xFF97, 0xFF9E, // 0x04C0 
0xFFA0, 0xFFA0, 0xFF9E, 0xFFA7, 0xFFA5, 0xFFA8, 0xFFA3, 0xFFA9, // 0x04D0 
0xFFAE, 0xFF9A, 0xFFA5, 0xFF97, 0xFFAE, 0xFF95, 0xFFA6, 0xFF99, // 0x04E0 
0xFFAF, 0xFF98, 0xFFA2, 0xFFA0, 0xFFAB, 0xFFA9, 0xFFA3, 0xFFA6, // 0x04F0 
0xFFA4, 0xFFAE, 0xFFA7, 0xFFA5, 0xFFA7, 0xFFA7, 0xFFA9, 0xFFA6, // 0x0500 
0xFFAC, 0xFFA6, 0xFFB0, 0xFFA3, 0xFFB7, 0xFFAD, 0xFFB7, 0xFFA9, // 0x0510 
0xFFAF, 0xFFAB, 0xFFA8, 0xFFA8, 0xFFAC, 0xFFAD, 0xFFAB, 0xFFAA, // 0x0520 
0xFFAF, 0xFFAE, 0xFFB6, 0xFFA7, 0xFFBC, 0xFFAB, 0xFFC4, 0xFFA4, // 0x0530 
0xFF93, 0xFF95, 0xFF90, 0xFF94, 0xFF94, 0xFF93, 0xFF92, 0xFF96, // 0x0540 
0xFF99, 0xFF93, 0xFF96, 0xFF97, 0xFFA0, 0xFF9E, 0xFF9B, 0xFF9E, // 0x0550 
0xFFA4, 0xFF93, 0xFF9D, 0xFF94, 0xFFA9, 0xFF96, 0xFF9F, 0xFF96, // 0x0560 
0xFFAB, 0xFF97, 0xFFA1, 0xFFA5, 0xFFA9, 0xFFAA, 0xFFA4, 0xFFA6, // 0x0570 
0xFFA4, 0xFFAC, 0xFFA4, 0xFFA6, 0xFFA6, 0xFFA7, 0xFFA6, 0xFFA1, // 0x0580 
0xFFA5, 0xFFA6, 0xFFA4, 0xFFA3, 0xFFA7, 0xFFA4, 0xFFA7, 0xFF9F, // 0x0590 
0xFFAB, 0xFFA3, 0xFFA9, 0xFFA3, 0xFFAA, 0xFFA7, 0xFFAB, 0xFFA6, // 0x05A0 
0xFFAE, 0xFFAA, 0xFFB7, 0xFFA6, 0xFFBB, 0xFFAA, 0xFFBB, 0xFFA3, // 0x05B0 
0xFF87, 0xFF8A, 0xFF84, 0xFF8C, 0xFF8A, 0xFF8B, 0xFF86, 0xFF8B, // 0x05C0 
0xFF8B, 0xFF89, 0xFF85, 0xFF8B, 0xFF8F, 0xFF89, 0xFF8A, 0xFF8B, // 0x05D0 
0xFF91, 0xFF8A, 0xFF8C, 0xFF8D, 0xFF9A, 0xFF8B, 0xFF95, 0xFF8E, // 0x05E0 
0xFF9E, 0xFF93, 0xFF98, 0xFF9D, 0xFF9E, 0xFF9D, 0xFF9A, 0xFF99, // 0x05F0 
0x4DFA, 0x1A56, 0x7FFF, 0x1A56, 0x7FFF, 0x1A55, 0x7FFF, 0x1A55, // 0x0600 
0xFFB9, 0xCE07, 0x1584, 0xD653, 0xFFF9, 0x0009, 0x0000, 0xFFFD, // 0x0610 
0x1976, 0x03FD, 0x0297, 0x7FFF, 0x1976, 0x03FD, 0x0297, 0x7FFF, // 0x0620 
0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, // 0x0630 
0x0695, 0x7FFF, 0x1A56, 0x7FFF, 0x1A56, 0x7FFF, 0x1A55, 0x7FFF, // 0x0640 
0xFFBD, 0xF57A, 0xCEF2, 0xD8E0, 0x0009, 0xFFFD, 0xFFFC, 0x0000, // 0x0650 
0x00ED, 0x0046, 0x2AD6, 0x0035, 0x00EE, 0x0046, 0x2AD6, 0x0035, // 0x0660 
0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, // 0x0670 
0x1901, 0x0000
};

const static u16 sample_frame_1[834] =
{
0xFFB3, 0xFFAD, 0xFFB4, 0xFFAA, 0xFFB3, 0xFFAD, 0xFFB6, 0xFFA8, // 0x0000 
0xFFB2, 0xFFA9, 0xFFB4, 0xFFA4, 0xFFB1, 0xFFA6, 0xFFB4, 0xFFA1, // 0x0010 
0xFFB4, 0xFFA8, 0xFFB4, 0xFFA1, 0xFFB6, 0xFFA8, 0xFFB5, 0xFFA2, // 0x0020 
0xFFBA, 0xFFA7, 0xFFB8, 0xFFA3, 0xFFB6, 0xFFAA, 0xFFBD, 0xFFA3, // 0x0030 
0xFFAC, 0xFFA8, 0xFFA5, 0xFFA8, 0xFFAC, 0xFFA6, 0xFFA5, 0xFFA5, // 0x0040 
0xFFAA, 0xFFA2, 0xFFA2, 0xFFA2, 0xFFAB, 0xFF9F, 0xFFA0, 0xFFA1, // 0x0050 
0xFFAB, 0xFFA0, 0xFFA4, 0xFFA2, 0xFFAB, 0xFFA3, 0xFFA6, 0xFFA4, // 0x0060 
0xFFB1, 0xFFA2, 0xFFA9, 0xFFA3, 0xFFB0, 0xFFA4, 0xFFAD, 0xFFA3, // 0x0070 
0xFFB2, 0xFFAF, 0xFFB4, 0xFFA8, 0xFFB1, 0xFFAE, 0xFFB1, 0xFFA5, // 0x0080 
0xFFB1, 0xFFAA, 0xFFB3, 0xFFA3, 0xFFB2, 0xFFA7, 0xFFB1, 0xFFA3, // 0x0090 
0xFFB5, 0xFFA6, 0xFFB1, 0xFFA0, 0xFFB6, 0xFFA7, 0xFFB5, 0xFFA0, // 0x00A0 
0xFFB8, 0xFFA7, 0xFFB7, 0xFFA2, 0xFFB6, 0xFFA8, 0xFFB9, 0xFF9F, // 0x00B0 
0xFFAA, 0xFFA7, 0xFFA4, 0xFFA7, 0xFFA9, 0xFFA5, 0xFFA3, 0xFFA6, // 0x00C0 
0xFFA9, 0xFFA3, 0xFFA3, 0xFFA2, 0xFFAA, 0xFF9F, 0xFFA2, 0xFFA3, // 0x00D0 
0xFFAD, 0xFFA0, 0xFFA2, 0xFFA2, 0xFFAD, 0xFFA2, 0xFFA6, 0xFFA1, // 0x00E0 
0xFFB1, 0xFFA3, 0xFFA7, 0xFFA3, 0xFFAD, 0xFFA1, 0xFFA9, 0xFFA1, // 0x00F0 
0xFFB3, 0xFFAF, 0xFFB5, 0xFFAA, 0xFFB2, 0xFFAD, 0xFFB2, 0xFFA6, // 0x0100 
0xFFB4, 0xFFAB, 0xFFB1, 0xFFA4, 0xFFB1, 0xFFA8, 0xFFB3, 0xFFA0, // 0x0110 
0xFFB5, 0xFFA6, 0xFFB2, 0xFFA3, 0xFFB2, 0xFFA8, 0xFFB4, 0xFFA1, // 0x0120 
0xFFB6, 0xFFA6, 0xFFB8, 0xFFA2, 0xFFB4, 0xFFA7, 0xFFB9, 0xFF9C, // 0x0130 
0xFFAB, 0xFFA5, 0xFFA3, 0xFFA6, 0xFFAA, 0xFFA4, 0xFFA4, 0xFFA4, // 0x0140 
0xFFB0, 0xFFA1, 0xFFA4, 0xFFA3, 0xFFA9, 0xFFA1, 0xFFA0, 0xFFA0, // 0x0150 
0xFFAE, 0xFF9F, 0xFFA2, 0xFFA3, 0xFFAD, 0xFFA0, 0xFFA4, 0xFFA1, // 0x0160 
0xFFAE, 0xFF9E, 0xFFA8, 0xFFA1, 0xFFAC, 0xFFA0, 0xFFA8, 0xFF9D, // 0x0170 
0xFFB0, 0xFFAE, 0xFFB2, 0xFFA8, 0xFFB2, 0xFFAC, 0xFFB3, 0xFFA9, // 0x0180 
0xFFB8, 0xFFB8, 0xFFB6, 0xFFAB, 0xFFB2, 0xFFAA, 0xFFB1, 0xFFA1, // 0x0190 
0xFFB2, 0xFFA5, 0xFFB2, 0xFFA0, 0xFFB2, 0xFFA5, 0xFFB5, 0xFFA1, // 0x01A0 
0xFFB2, 0xFFA6, 0xFFB4, 0xFFA3, 0xFFB4, 0xFFA5, 0xFFB9, 0xFF9B, // 0x01B0 
0xFFA6, 0xFFA4, 0xFFA2, 0xFFA4, 0xFFA7, 0xFFA0, 0xFFA2, 0xFFA3, // 0x01C0 
0xFFBB, 0xFFA7, 0xFFAF, 0xFFAA, 0xFFAF, 0xFFA1, 0xFFA1, 0xFFA1, // 0x01D0 
0xFFA9, 0xFF9D, 0xFFA0, 0xFF9F, 0xFFA8, 0xFF9F, 0xFFA2, 0xFF9F, // 0x01E0 
0xFFAC, 0xFF9E, 0xFFA4, 0xFFA0, 0xFFAC, 0xFF9F, 0xFFA6, 0xFF9B, // 0x01F0 
0xFFAF, 0xFFAF, 0xFFB3, 0xFFA9, 0xFFAF, 0xFFAF, 0xFFB4, 0xFFB0, // 0x0200 
0xFFBB, 0xFFC0, 0xFFC6, 0xFFB7, 0xFFC0, 0xFFB7, 0xFFB6, 0xFFA7, // 0x0210 
0xFFB0, 0xFFA6, 0xFFB1, 0xFFA0, 0xFFB3, 0xFFA4, 0xFFB2, 0xFFA0, // 0x0220 
0xFFB4, 0xFFA4, 0xFFB4, 0xFFA0, 0xFFB4, 0xFFA5, 0xFFB7, 0xFF9A, // 0x0230 
0xFFA6, 0xFFA2, 0xFF9F, 0xFFA1, 0xFFA8, 0xFFA2, 0xFFAA, 0xFFA4, // 0x0240 
0xFFBE, 0xFFB2, 0xFFB6, 0xFFB4, 0xFFBE, 0xFFAD, 0xFFAC, 0xFFA6, // 0x0250 
0xFFAC, 0xFF9D, 0xFFA0, 0xFF9D, 0xFFA9, 0xFF9D, 0xFFA0, 0xFF9F, // 0x0260 
0xFFAA, 0xFF9C, 0xFFA1, 0xFF9F, 0xFFAC, 0xFF9D, 0xFFA2, 0xFF9C, // 0x0270 
0xFFB3, 0xFFAF, 0xFFB3, 0xFFAA, 0xFFB4, 0xFFB1, 0xFFB5, 0xFFBB, // 0x0280 
0xFFC8, 0xFFC4, 0xFFC8, 0xFFBC, 0xFFC9, 0xFFBF, 0xFFC2, 0xFFB5, // 0x0290 
0xFFBD, 0xFFB0, 0xFFB5, 0xFFA0, 0xFFB2, 0xFFA6, 0xFFB0, 0xFF9E, // 0x02A0 
0xFFB3, 0xFFA3, 0xFFB2, 0xFF9E, 0xFFB2, 0xFFA4, 0xFFB4, 0xFF9B, // 0x02B0 
0xFFA8, 0xFFA1, 0xFF9D, 0xFFA2, 0xFFAC, 0xFFA1, 0xFFB1, 0xFFAA, // 0x02C0 
0xFFC7, 0xFFB7, 0xFFB9, 0xFFB8, 0xFFC0, 0xFFB5, 0xFFB2, 0xFFB1, // 0x02D0 
0xFFBB, 0xFFA8, 0xFFA5, 0xFFA0, 0xFFA7, 0xFF9B, 0xFF9C, 0xFF9D, // 0x02E0 
0xFFA9, 0xFF9A, 0xFFA1, 0xFF9D, 0xFFA9, 0xFF9C, 0xFFA5, 0xFF9A, // 0x02F0 
0xFFAE, 0xFFAD, 0xFFAD, 0xFFA7, 0xFFB1, 0xFFB8, 0xFFBB, 0xFFC0, // 0x0300 
0xFFCB, 0xFFCA, 0xFFCE, 0xFFC1, 0xFFCB, 0xFFBF, 0xFFC5, 0xFFB6, // 0x0310 
0xFFC6, 0xFFB6, 0xFFBD, 0xFFA0, 0xFFB2, 0xFFA4, 0xFFB0, 0xFF9E, // 0x0320 
0xFFB3, 0xFFA1, 0xFFB1, 0xFF9F, 0xFFB1, 0xFFA4, 0xFFB4, 0xFF9C, // 0x0330 
0xFFA3, 0xFF9E, 0xFF9A, 0xFF9F, 0xFFAE, 0xFFA0, 0xFFB1, 0xFFB3, // 0x0340 
0xFFC1, 0xFFBB, 0xFFB9, 0xFFBF, 0xFFBF, 0xFFB7, 0xFFB1, 0xFFB3, // 0x0350 
0xFFB8, 0xFFB0, 0xFFA0, 0xFFA6, 0xFFA7, 0xFF9B, 0xFF9E, 0xFF99, // 0x0360 
0xFFAB, 0xFF9A, 0xFFA0, 0xFF9D, 0xFFAA, 0xFF9D, 0xFFA2, 0xFF9A, // 0x0370 
0xFFAC, 0xFFAF, 0xFFB0, 0xFFA9, 0xFFB1, 0xFFBD, 0xFFC3, 0xFFBA, // 0x0380 
0xFFCA, 0xFFC2, 0xFFCD, 0xFFBC, 0xFFCA, 0xFFBE, 0xFFC8, 0xFFB7, // 0x0390 
0xFFC6, 0xFFB1, 0xFFB9, 0xFFA0, 0xFFB2, 0xFFA5, 0xFFAF, 0xFF9D, // 0x03A0 
0xFFB3, 0xFFA4, 0xFFB0, 0xFFA0, 0xFFB0, 0xFFA3, 0xFFB4, 0xFF9B, // 0x03B0 
0xFF9E, 0xFF9C, 0xFF9C, 0xFF9F, 0xFFAE, 0xFFA4, 0xFFAE, 0xFFB3, // 0x03C0 
0xFFB8, 0xFFB5, 0xFFAF, 0xFFB9, 0xFFBA, 0xFFB3, 0xFFAF, 0xFFB2, // 0x03D0 
0xFFB4, 0xFFAF, 0xFF9D, 0xFF9D, 0xFFA5, 0xFF9B, 0xFF9D, 0xFF9A, // 0x03E0 
0xFFA9, 0xFF9A, 0xFFA1, 0xFF9C, 0xFFA8, 0xFF9B, 0xFFA3, 0xFF9A, // 0x03F0 
0xFFAE, 0xFFAF, 0xFFB0, 0xFFA8, 0xFFB6, 0xFFB5, 0xFFC0, 0xFFB5, // 0x0400 
0xFFC3, 0xFFBC, 0xFFC2, 0xFFB6, 0xFFC4, 0xFFBD, 0xFFC2, 0xFFB0, // 0x0410 
0xFFC4, 0xFFA9, 0xFFB2, 0xFF9E, 0xFFAE, 0xFFA3, 0xFFAE, 0xFF9E, // 0x0420 
0xFFB0, 0xFFA3, 0xFFAF, 0xFFA1, 0xFFB2, 0xFFA6, 0xFFB3, 0xFF9E, // 0x0430 
0xFF9E, 0xFF9A, 0xFF98, 0xFF9F, 0xFFA4, 0xFFA4, 0xFFA2, 0xFFAF, // 0x0440 
0xFFB0, 0xFFAC, 0xFFAA, 0xFFAD, 0xFFB6, 0xFFB0, 0xFFAA, 0xFFAF, // 0x0450 
0xFFAB, 0xFFA6, 0xFF99, 0xFF9A, 0xFFA3, 0xFF98, 0xFF99, 0xFF9B, // 0x0460 
0xFFA7, 0xFF99, 0xFFA2, 0xFF9A, 0xFFAE, 0xFF9F, 0xFFA3, 0xFF9A, // 0x0470 
0xFFA7, 0xFFAC, 0xFFAA, 0xFFA5, 0xFFAA, 0xFFAA, 0xFFB0, 0xFFA8, // 0x0480 
0xFFB9, 0xFFB1, 0xFFBF, 0xFFB2, 0xFFBD, 0xFFB8, 0xFFC0, 0xFFA7, // 0x0490 
0xFFBA, 0xFFA4, 0xFFAE, 0xFF9D, 0xFFAC, 0xFFA3, 0xFFAC, 0xFF9D, // 0x04A0 
0xFFB0, 0xFFA4, 0xFFB0, 0xFFAA, 0xFFBB, 0xFFB3, 0xFFBC, 0xFFA3, // 0x04B0 
0xFF99, 0xFF96, 0xFF8F, 0xFF99, 0xFF97, 0xFF98, 0xFF93, 0xFF9E, // 0x04C0 
0xFF9E, 0xFFA0, 0xFF9E, 0xFFA7, 0xFFAC, 0xFFA8, 0xFF9F, 0xFFA9, // 0x04D0 
0xFFA1, 0xFF9A, 0xFF94, 0xFF97, 0xFFA0, 0xFF95, 0xFF98, 0xFF99, // 0x04E0 
0xFFA6, 0xFF98, 0xFFA5, 0xFFA0, 0xFFB8, 0xFFA9, 0xFFAD, 0xFFA6, // 0x04F0 
0xFFA4, 0xFFAC, 0xFFA7, 0xFFA3, 0xFFA7, 0xFFA7, 0xFFA9, 0xFFA3, // 0x0500 
0xFFAC, 0xFFA6, 0xFFB0, 0xFFA4, 0xFFB7, 0xFFAD, 0xFFB7, 0xFFA1, // 0x0510 
0xFFAF, 0xFF9F, 0xFFA8, 0xFF9C, 0xFFAC, 0xFFA3, 0xFFAB, 0xFF9E, // 0x0520 
0xFFAF, 0xFFAA, 0xFFB6, 0xFFAE, 0xFFBC, 0xFFBA, 0xFFC4, 0xFFA9, // 0x0530 
0xFF95, 0xFF95, 0xFF8E, 0xFF94, 0xFF96, 0xFF93, 0xFF91, 0xFF96, // 0x0540 
0xFF99, 0xFF93, 0xFF94, 0xFF97, 0xFF9E, 0xFF9E, 0xFF94, 0xFF9E, // 0x0550 
0xFF9D, 0xFF93, 0xFF91, 0xFF94, 0xFF9F, 0xFF96, 0xFF95, 0xFF96, // 0x0560 
0xFFA8, 0xFF97, 0xFFA6, 0xFFA5, 0xFFB6, 0xFFAA, 0xFFAB, 0xFFA6, // 0x0570 
0xFFA4, 0xFFAA, 0xFFA4, 0xFFA2, 0xFFA6, 0xFFA7, 0xFFA6, 0xFF9E, // 0x0580 
0xFFA5, 0xFFA4, 0xFFA4, 0xFF9F, 0xFFA7, 0xFFA1, 0xFFA7, 0xFF9B, // 0x0590 
0xFFAB, 0xFFA0, 0xFFA9, 0xFF9D, 0xFFAA, 0xFFA1, 0xFFAB, 0xFF9F, // 0x05A0 
0xFFAE, 0xFFAE, 0xFFB7, 0xFFAD, 0xFFBB, 0xFFB5, 0xFFBB, 0xFFA3, // 0x05B0 
0xFF87, 0xFF8A, 0xFF80, 0xFF8C, 0xFF8B, 0xFF8B, 0xFF83, 0xFF8B, // 0x05C0 
0xFF8B, 0xFF89, 0xFF86, 0xFF8B, 0xFF8E, 0xFF89, 0xFF86, 0xFF8B, // 0x05D0 
0xFF93, 0xFF8A, 0xFF87, 0xFF8D, 0xFF95, 0xFF8B, 0xFF8D, 0xFF8E, // 0x05E0 
0xFFA6, 0xFF93, 0xFFA0, 0xFF9D, 0xFFA9, 0xFF9D, 0xFF9C, 0xFF99, // 0x05F0 
0x4DFA, 0x1A58, 0x7FFF, 0x1A58, 0x7FFF, 0x1A57, 0x7FFF, 0x1A57, // 0x0600 
0xFFB9, 0xCE35, 0x1584, 0xD64E, 0xFFF9, 0x000B, 0x0000, 0xFFFE, // 0x0610 
0x1976, 0x03FD, 0x0297, 0x7FFF, 0x1976, 0x03FD, 0x0297, 0x7FFF, // 0x0620 
0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, // 0x0630 
0x0696, 0x7FFF, 0x1A58, 0x7FFF, 0x1A58, 0x7FFF, 0x1A57, 0x7FFF, // 0x0640 
0xFFBF, 0xF57A, 0xCF18, 0xD8E0, 0x000A, 0xFFFD, 0xFFFE, 0x0000, // 0x0650 
0x00F1, 0x0046, 0x2AC3, 0x0035, 0x00F1, 0x0046, 0x2AC3, 0x0035, // 0x0660 
0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, // 0x0670 
0x1901, 0x0001
};

#endif  // SIMULATION

ErrorStatus  wait_flag_set    (volatile u16 *reg, u16 Flag);
ErrorStatus  wait_flag_reset  (volatile u16 *reg, u16 Flag);

static i2c_control  i2cc = {0};


/*******************************************************************************
// Wait until I2C flag set
// input:
//   I2C_Flag - I2C flag (one of I2C_F_XXX values)
// return:
//   SUCCESS if flag set or ERROR in case of timeout
*******************************************************************************/
ErrorStatus wait_flag_set (volatile u16 *reg, u16 Flag) 
{
	u32 timer;

  timer_reset (&timer);
	// Wait for flag to be set
	while (timer_active (&timer, 3)) 
  {
		if ((*reg & Flag) == Flag)
    {
      return SUCCESS;
    }
	}
	return ERROR;
}

/*******************************************************************************
// Wait until I2C flag cleared
// input:
//   I2C_Flag - I2C flag (one of I2C_F_XXX values)
// return:
//   SUCCESS if flag cleared or ERROR in case of timeout
*******************************************************************************/
ErrorStatus wait_flag_reset (volatile u16 *reg, u16 Flag) 
{
  u32 timer;
  
  timer_reset (&timer);
	while (timer_active (&timer, 3)) // Wait until flag cleared
  {
		if (!(*reg & Flag)) return SUCCESS;
	}
	return ERROR;
}

ErrorStatus i2c_init (void)
{
  const u32 i2c_APB_freq = 36;  // частота шины APB 32МГц
  const u32 i2c_freq = 400; // частота i2c= 400 кГц
  // CCR = 45, это кол-во тактов APB1 на полупериод SCL (36МГц/(400КГц * 2))
//  u32 i2c_ccr = 180;  // 36MHz / (2 * 100kHz) = 180
  const u32 i2c_ccr = (i2c_APB_freq * 1000) / (2 * i2c_freq);  // i2c_APB_freq / (2 * 400kHz) = 45
  // TRISE = 9, это кол-во тактов APB1, через которое проверяется состояние SCL 
  // при переходе в откл. состояние (из 0 в 1), 
  // это время должно быть чуть больше 1 мкс (1мкс/(1/i2c_APB_freq)+1) = i2c_APB_freq + 1
  const u32 t_rise = i2c_APB_freq + 1;
  
//------------------------Грабли из Errata------------------------------------//
//1.Disable the I2C peripheral by clearing the PE bit in I2Cx_CR1 register.
   I2C1->CR1 &= ~I2C_CR1_PE;
//2. Configure the SCL and SDA I/Os as General Purpose Output Open-Drain, High level (Write 1 to GPIOx_ODR).
  GPIOB->CRL = GPIO_CRL_MODE0_INPUT     | GPIO_CRL_CNF0_IN_FL
            | GPIO_CRL_MODE1_INPUT      | GPIO_CRL_CNF1_IN_FL
            | GPIO_CRL_MODE2_INPUT      | GPIO_CRL_CNF2_IN_FL
            | GPIO_CRL_MODE3_INPUT      | GPIO_CRL_CNF3_IN_FL
            | GPIO_CRL_MODE4_INPUT      | GPIO_CRL_CNF4_IN_FL
            | GPIO_CRL_MODE5_INPUT      | GPIO_CRL_CNF5_IN_FL
            | GPIO_CRL_MODE6_OUTPUT10M  | GPIO_CRL_CNF6_OUT_GP_PP
            | GPIO_CRL_MODE7_OUTPUT10M  | GPIO_CRL_CNF7_OUT_GP_PP;
  GPIOB->BSRR = GPIO_BSRR_BS6 | GPIO_BSRR_BS7;
//3. Check SCL and SDA High level in GPIOx_IDR.
  wait_flag_set ((u16 *)GPIOB->IDR, GPIO_IDR_IDR6 | GPIO_IDR_IDR7);
//  while (!(GPIOB->IDR &(GPIO_IDR_IDR6 | GPIO_IDR_IDR7)));
//4. Configure the SDA I/O as General Purpose Output Open-Drain, Low level (Write 0 to GPIOx_ODR).
  GPIOB->CRL = GPIO_CRL_MODE0_INPUT     | GPIO_CRL_CNF0_IN_FL
            | GPIO_CRL_MODE1_INPUT      | GPIO_CRL_CNF1_IN_FL
            | GPIO_CRL_MODE2_INPUT      | GPIO_CRL_CNF2_IN_FL
            | GPIO_CRL_MODE3_INPUT      | GPIO_CRL_CNF3_IN_FL
            | GPIO_CRL_MODE4_INPUT      | GPIO_CRL_CNF4_IN_FL
            | GPIO_CRL_MODE5_INPUT      | GPIO_CRL_CNF5_IN_FL
            | GPIO_CRL_MODE6_OUTPUT10M  | GPIO_CRL_CNF6_OUT_GP_PP
            | GPIO_CRL_MODE7_OUTPUT10M  | GPIO_CRL_CNF7_OUT_GP_OD;
  GPIOB->BRR = GPIO_BRR_BR7;
//5. Check SDA Low level in GPIOx_IDR.
  wait_flag_reset ((u16 *)GPIOB->IDR, GPIO_IDR_IDR7);
//  while (GPIOB->IDR & GPIO_IDR_IDR7);
//6. Configure the SCL I/O as General Purpose Output Open-Drain, Low level (Write 0 to GPIOx_ODR).
  GPIOB->CRL = GPIO_CRL_MODE0_INPUT     | GPIO_CRL_CNF0_IN_FL
            | GPIO_CRL_MODE1_INPUT      | GPIO_CRL_CNF1_IN_FL
            | GPIO_CRL_MODE2_INPUT      | GPIO_CRL_CNF2_IN_FL
            | GPIO_CRL_MODE3_INPUT      | GPIO_CRL_CNF3_IN_FL
            | GPIO_CRL_MODE4_INPUT      | GPIO_CRL_CNF4_IN_FL
            | GPIO_CRL_MODE5_INPUT      | GPIO_CRL_CNF5_IN_FL
            | GPIO_CRL_MODE6_OUTPUT10M  | GPIO_CRL_CNF6_OUT_GP_OD
            | GPIO_CRL_MODE7_OUTPUT10M  | GPIO_CRL_CNF7_OUT_GP_OD;
  GPIOB->BRR = GPIO_BRR_BR6;
//7. Check SCL Low level in GPIOx_IDR.
  wait_flag_reset ((u16 *)GPIOB->IDR, GPIO_IDR_IDR6);
//  while (GPIOB->IDR & GPIO_IDR_IDR6);
//8. Configure the SCL I/O as General Purpose Output Open-Drain, High level (Write 1 to GPIOx_ODR).
  GPIOB->BSRR = GPIO_BSRR_BS6;
//9. Check SCL High level in GPIOx_IDR.
  wait_flag_set ((u16 *)GPIOB->IDR, GPIO_IDR_IDR6);
//  while (!(GPIOB->IDR & GPIO_IDR_IDR6));
//10. Configure the SDA I/O as General Purpose Output Open-Drain , High level (Write 1 to GPIOx_ODR).
  GPIOB->BSRR = GPIO_BSRR_BS7;
//11. Check SDA High level in GPIOx_IDR.
  wait_flag_set ((u16 *)GPIOB->IDR, GPIO_IDR_IDR7);
//  while (!(GPIOB->IDR & GPIO_IDR_IDR7));
//12. Configure the SCL and SDA I/Os as Alternate function Open-Drain.
  GPIOB->CRL = GPIO_CRL_MODE0_INPUT     | GPIO_CRL_CNF0_IN_FL
            | GPIO_CRL_MODE1_INPUT      | GPIO_CRL_CNF1_IN_FL
            | GPIO_CRL_MODE2_INPUT      | GPIO_CRL_CNF2_IN_FL
            | GPIO_CRL_MODE3_INPUT      | GPIO_CRL_CNF3_IN_FL
            | GPIO_CRL_MODE4_INPUT      | GPIO_CRL_CNF4_IN_FL
            | GPIO_CRL_MODE5_INPUT      | GPIO_CRL_CNF5_IN_FL
            | GPIO_CRL_MODE6_OUTPUT10M  | GPIO_CRL_CNF6_OUT_AF_OD
            | GPIO_CRL_MODE7_OUTPUT10M  | GPIO_CRL_CNF7_OUT_AF_OD;
//13. Set SWRST bit in I2Cx_CR1 register.
  I2C1->CR1 = I2C_CR1_SWRST;
//14. Clear SWRST bit in I2Cx_CR1 register.
  I2C1->CR1 = 0;
//15. Enable the I2C peripheral by setting the PE bit in I2Cx_CR1 register.
//----------------------------------------------------------------------------//
  I2C1->CR2 = (I2C_CR2_FREQ & (i2c_APB_freq / 2)) // Peripheral Clock Frequency in MHz */
        | I2C_CR2_ITERREN   * 1   // Error Interrupt Enable 
        | I2C_CR2_ITEVTEN   * 1   // Event Interrupt Enable 
        | I2C_CR2_ITBUFEN   * 1   // Buffer Interrupt Enable
        | I2C_CR2_DMAEN     * 0   // DMA Requests Enable
        | I2C_CR2_LAST      * 0;  // DMA Last Transfer 
  
  I2C1->TRISE = t_rise; 
  
  I2C1->CCR = (I2C_CCR_CCR & i2c_ccr)
        | I2C_CCR_FS_F;   // Fm mode 400 kHz
  // Set I2C own address: 0x00, 7-bit
	I2C1->OAR1 = (1 << 14); // Bit 14 should be kept as 1
  
  I2C1->CR1 = I2C_CR1_PE    * 1   // Peripheral Enable 
        | I2C_CR1_SMBUS     * 0   // SMBus Mode 
        | I2C_CR1_SMBTYPE   * 0   // SMBus Type 
        | I2C_CR1_ENARP     * 0   // ARP Enable 
        | I2C_CR1_ENPEC     * 0   // PEC Enable 
        | I2C_CR1_ENGC      * 0   // General Call Enable 
        | I2C_CR1_NOSTRETCH * 0   // Clock Stretching Disable (Slave mode) 
        | I2C_CR1_START     * 0   // Start Generation 
        | I2C_CR1_STOP      * 0   // Stop Generation 
        | I2C_CR1_ACK       * 1   // Acknowledge Enable 
        | I2C_CR1_POS       * 0   // Acknowledge/PEC Position (for data reception)
        | I2C_CR1_PEC       * 0   // Packet Error Checking
        | I2C_CR1_ALERT     * 0   // SMBus Alert
        | I2C_CR1_SWRST     * 0;  // Software Reset

	// Wait until I2C bus is free
  ErrorStatus stat;
  stat = wait_flag_reset (&I2C1->SR2, I2C_SR2_BUSY);
  return stat;
}

ErrorStatus i2c_write (u8 addr, u8 *cmd, u16 len, u8 cont)
{
  I2C1->CR1 |= I2C_CR1_START;//стартуем
  if (wait_flag_set (&I2C1->SR1, I2C_SR1_SB) == ERROR) return ERROR;  // Wait for EV5

  I2C1->DR = addr & ~0x01; //передаем адрес устройства, бит 0 = 0 (запись)
  if (wait_flag_set (&I2C1->SR1, I2C_SR1_ADDR) == ERROR) return ERROR;  // Wait for EV6
  if (I2C1->SR1 & I2C_SR1_AF) return ERROR;  // if NACK
  (void) I2C1->SR1;  // clear ADDR
  (void) I2C1->SR2;  // clear ADDR

	I2C1->DR = *cmd++;  // Send first byte (EV8)
	while (--len)       // Send rest of data (if present)
  {
		if (wait_flag_set (&I2C1->SR1, I2C_SR1_TXE) == ERROR) return ERROR; // Wait for BTF flag set
		I2C1->DR = *cmd++;// Transmit byte via I2C
	}
	if (wait_flag_set (&I2C1->SR1, I2C_SR1_TXE | I2C_SR1_BTF) == ERROR) return ERROR; // Wait for BTF flag set

  if (!cont)
  {
    I2C1->CR1 |= I2C_CR1_STOP;
    if (wait_flag_reset (&I2C1->SR1, I2C_SR1_STOPF) == ERROR) return ERROR;
  } 
  return SUCCESS;
}


ErrorStatus i2c_read (u8 addr, u8 *data, u16 len)
{
	I2C1->CR1 |= I2C_CR1_START; //рестарт!!!
	if (wait_flag_set (&I2C1->SR1, I2C_SR1_SB) == ERROR) return ERROR;  // Wait for EV5

	//передаем адрес устройства, но теперь для чтения
	I2C1->DR = addr | 0x01;
	if (wait_flag_set (&I2C1->SR1, I2C_SR1_ADDR) == ERROR) return ERROR; // Wait for EV6
  
	// There are can be three cases:
	//   read 1 byte
	//   read 2 bytes
	//   read more than 2 bytes
	if (len == 1) // Receive 1 byte (AN2824 figure 2)
  {
		I2C1->CR1 &= ~I2C_CR1_ACK;  // Disable I2C acknowledgment	
		__disable_irq();            // EV6_1 must be atomic operation (AN2824)
		(void) I2C1->SR1;           // Clear ADDR bit
		(void) I2C1->SR2;
		I2C1->CR1 |= I2C_CR1_STOP;  // Generate a STOP condition
		__enable_irq();
		// Wait for RxNE flag (receive buffer not empty) EV7
		if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;
		*data = (u8)I2C1->DR;       // Read received byte
	} 
  else if (len == 2) // Receive 2 bytes (AN2824 figure 2)
  {
		I2C1->CR1 |= I2C_CR1_POS;   // Set POS flag (NACK position next)
		__disable_irq();            // EV6_1 must be atomic operation (AN2824)
    (void) I2C1->SR1;
		(void) I2C1->SR2;           // Clear ADDR bit
		I2C1->CR1 &= ~I2C_CR1_ACK;  // Disable I2C acknowledgment
		__enable_irq();
		// Wait for BTF flag set (byte transfer finished) EV7_3
		if (wait_flag_set (&I2C1->SR1, I2C_SR1_BTF) == ERROR) return ERROR;
		__disable_irq();            // This should be atomic operation
		I2C1->CR1 |= I2C_CR1_STOP;  // Generate a STOP condition
		*data++ = (u8)I2C1->DR;     // Read first received byte
		__enable_irq(); 
		*data = (u8)I2C1->DR;       // Read second received byte
   I2C1->CR1 &= ~I2C_CR1_POS;   // Clear POS flag // NACK position current
	} 
  else // Receive more than 2 bytes (AN2824 figure 1)
  {
    (void) I2C1->SR1;
		(void) I2C1->SR2;           // Clear ADDR bit
		while (len-- > 2)          // Read received bytes into buffer
    {
			// Wait for BTF (cannot guarantee 1 transfer completion time)
			if (wait_flag_set (&I2C1->SR1, I2C_SR1_BTF) == ERROR) return ERROR;
			*data++ = (u8)I2C1->DR;
		}
		// Wait for BTF flag set (byte transfer finished) EV7_2
		if (wait_flag_set (&I2C1->SR1, I2C_SR1_BTF) == ERROR) return ERROR;
		I2C1->CR1 &= ~I2C_CR1_ACK;  // Disable the I2C acknowledgment
		__disable_irq();
		I2C1->CR1 |= I2C_CR1_STOP;  // Generate a STOP condition
		*data++ = (u8)I2C1->DR;     // Read received byte N-1
		__enable_irq();
		// Wait for last byte received
	  if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;
		*data = (u8)I2C1->DR;// Read last received byte
	}
	// Wait for a STOP flag
	if (wait_flag_reset (&I2C1->SR1, I2C_SR1_STOPF) == ERROR) return ERROR;
  I2C1->CR1 |= I2C_CR1_ACK;   // Enable Acknowledgment
  
	return SUCCESS;	
}


ErrorStatus i2c_read16 (u8 addr, u16 *data, u16 len)
{
  u8 first_byte;
  u8 second_byte;
  
	I2C1->CR1 |= I2C_CR1_START; //рестарт!!!
	if (wait_flag_set (&I2C1->SR1, I2C_SR1_SB) == ERROR) return ERROR; // Wait for EV5
	//передаем адрес устройства, но теперь для чтения
	I2C1->DR = addr | 0x01;
	if (wait_flag_set (&I2C1->SR1, I2C_SR1_ADDR) == ERROR) return ERROR; // Wait for EV6
  
  if (len == 1) // Receive only 2 bytes (AN2824 figure 2)
  {
    I2C1->CR1 |= I2C_CR1_POS;       // Set POS flag (NACK position next)
    __disable_irq();                // This should be atomic operation
    (void) I2C1->SR1;               
    (void) I2C1->SR2;               // reset ADDR
    I2C1->CR1 &= ~I2C_CR1_ACK;      // NACK, Disable the I2C acknowledgment
    __enable_irq();
    // Wait for BTF flag set (byte transfer finished) EV7_3
    if (wait_flag_set (&I2C1->SR1, I2C_SR1_BTF) == ERROR) return ERROR;
    __disable_irq();                // This should be atomic operation
    I2C1->CR1 |= I2C_CR1_STOP;      // Generate a STOP condition
    first_byte = I2C1->DR;  // Read received byte N-1
    __enable_irq();
    second_byte = I2C1->DR;      // Read second received byte
    *data = (first_byte << 8) | second_byte;
    // Wait for a STOP flag
    if (wait_flag_reset (&I2C1->SR1, I2C_SR1_STOPF) == ERROR) return ERROR;
    I2C1->CR1 &= ~I2C_CR1_POS;  // Clear POS flag // NACK position current
  }
  else
  {
    (void) I2C1->SR1;                       
    (void) I2C1->SR2;                       // reset ADDR
    while (--len)
    {
      if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;
      first_byte = I2C1->DR;
      if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;
      second_byte = I2C1->DR;
      *data++ = (first_byte << 8) | second_byte;
    }
    // receive last two bytes
    if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;    
    I2C1->CR1 &= ~I2C_CR1_ACK;      // NACK, Disable the I2C acknowledgment
    __disable_irq();                // This should be atomic operation
    I2C1->CR1 |= I2C_CR1_STOP;      // Generate a STOP condition
    first_byte = I2C1->DR;          // Read received byte N-1
    __enable_irq();
    
    if (wait_flag_set (&I2C1->SR1, I2C_SR1_RXNE) == ERROR) return ERROR;
    second_byte = I2C1->DR;      // Read second received byte
    // Wait for a STOP flag
    if (wait_flag_reset (&I2C1->SR1, I2C_SR1_STOPF) == ERROR) return ERROR;
    *data = (first_byte << 8) | second_byte;
  }
  I2C1->CR1 |= I2C_CR1_ACK;   // Enable Acknowledgment
	return SUCCESS;	
}


void i2c_func (void)
{
  union
  {
    status_reg  status;
    control_reg control;
    u16         reg_16;
  };
  static pir_states pir_state = PIR_INIT_DELAY;
  static pir_states ppir_state = PIR_INIT;
  static u32 pir_timer;
  ErrorStatus err;
//  static int mode;

  switch (pir_state)
  {
  case PIR_INIT_DELAY:
    if (ppir_state != pir_state)
    {
      ppir_state = pir_state;
      g.par.const_data = &MLXdata;
      g.par.emissivity  = 0.95f;     // отражающая способность по умолчанию

      reg_16 = 0;
      control.en_subpage    = 1;
      control.refresh_rate  = MLX90640_REFRESH_VALUE;
      control.resolution    = MLX_CR1_RESOLUTION_18_BIT;
      control.chess         = 1;
      
      MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_CR1, reg_16);
      
      timer_reset (&pir_timer);
    }
    if (timer_end (&pir_timer, MLX90640_START_DELAY)) // 80ms + 2 / RefreshRate
    {      
      pir_state = PIR_INIT;
    }
    break;
    
  case PIR_INIT:
#ifdef  SIMULATION  // test data
    reg_16 = MLX90640_ExtractParameters ((u16 *)sample_eeprom_data, &g.par);   
#else
    reg_16 = MLX90640_DumpEE (MLX90640_ADDR, (u16 *)&g.frame);
    reg_16 = MLX90640_ExtractParameters ((u16 *)&g.frame, &g.par);  
#endif  // SIMULATION
    
    pir_state = PIR_READ_SBP0;
    break;
    
  case PIR_READ_SBP0:
    if (ppir_state != pir_state)
    {
      ppir_state = pir_state;
//      MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, (MLX_REG_STATUS_OVW_EN 
//                                                        | MLX_REG_STATUS_START_CONV));
      timer_reset (&pir_timer);
    }
    if (MLX90640_GetNewDataStatus (MLX90640_ADDR))
    {
#ifdef  SIMULATION
      memcpy (&g.frame, sample_frame_0, sizeof (sample_frame_0));
      err = SUCCESS;
#else
      err = MLX90640_GetFrameData (MLX90640_ADDR, &g.frame);
      
#endif  // SIMULATION
      
      MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, &reg_16);
      status.new_data = 0;
      MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, reg_16);
      MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, (u16 *)&g.frame.status);
      if (g.frame.status.new_data)
      {
        xEventGroupSetBits (g.events, M_WARNING);
      }
      else if (g.frame.status.subpage == 0)
      {
        pir_state = PIR_CALCULATE_SBP0;
      }
    }
    if (timer_end (&pir_timer, MLX90640_ERROR_DELAY))
    {
      pir_state = PIR_INIT_DELAY;
    }
    break;
    
  case PIR_CALCULATE_SBP0:
    if (ppir_state != pir_state)
    {
      ppir_state = pir_state;
      timer_reset (&pir_timer);
      MLX90640_CalculateTo (&g.frame, &g.par, g.to); //The object temperatures
//      MLX90640_GetImage (&g.frame, &g.par, g.image); //The image from the frame data is extracted and is stored in the mlx90640Image array
//      mode = MLX90640_GetCurMode (MLX90640_ADDR);
//      MLX90640_BadPixelsCorrection (g.par.brokenPixels, g.to, mode, &par);
//      MLX90640_BadPixelsCorrection (g.par.outlierPixels, g.to, mode, &par);
    }
    if (timer_end (&pir_timer, MLX90640_WAIT_DELAY))
    {
      pir_state = PIR_READ_SBP1;
    }
    break;

  case PIR_READ_SBP1:
    if (ppir_state != pir_state)
    {
      ppir_state = pir_state;
//      MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, (MLX_REG_STATUS_OVW_EN 
//                                                        | MLX_REG_STATUS_START_CONV));
      timer_reset (&pir_timer);
    }
    if (MLX90640_GetNewDataStatus (MLX90640_ADDR))
    {
#ifdef  SIMULATION
      memcpy (&g.frame, sample_frame_1, sizeof (sample_frame_1));
      err = SUCCESS;
#else
      err = MLX90640_GetFrameData (MLX90640_ADDR, &g.frame);
#endif  // SIMULATION

      MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, &reg_16);
      status.new_data = 0;
      MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, reg_16);
      MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, (u16 *)&g.frame.status);
      if (g.frame.status.new_data)
      {
        xEventGroupSetBits (g.events, M_WARNING);
      }
      else if (g.frame.status.subpage == 1)
      {
        pir_state = PIR_CALCULATE_SBP1;
      }
    }
    if (timer_end (&pir_timer, MLX90640_ERROR_DELAY))
    {
      pir_state = PIR_INIT_DELAY;
    }
    break;
    
  case PIR_CALCULATE_SBP1:
    if (ppir_state != pir_state)
    {
      ppir_state = pir_state;
      timer_reset (&pir_timer);
      MLX90640_CalculateTo (&g.frame, &g.par, g.to); //The object temperatures
//      MLX90640_GetImage (&g.frame, &g.par, g.image); //The image from the frame data is extracted and is stored in the mlx90640Image array
//    mode = MLX90640_GetCurMode (MLX90640_ADDR);
//    MLX90640_BadPixelsCorrection (g.par.brokenPixels, g.to, mode, &par);
//    MLX90640_BadPixelsCorrection (g.par.outlierPixels, g.to, mode, &par);
      xEventGroupSetBits (g.events, M_IR_READY);
    }
    if (timer_end (&pir_timer, MLX90640_WAIT_DELAY))
    {
      pir_state = PIR_READ_SBP0;
    }
    break;
    
  default:
    pir_state = PIR_INIT;
    break;
  }
  (void) err;
}


/*******************************************************************************
*
*******************************************************************************/
void i2c_task (void *param)
{
  union
  {
    status_reg  status;
    control_reg control;
    u16         reg_16;
  };
  
  (void) param;
  
  i2c_init ();
  
  // init delay
  g.par.const_data = &MLXdata;
  g.par.emissivity  = 0.95f;     // отражающая способность по умолчанию

  reg_16 = 0;
  control.en_subpage    = 1;
  control.refresh_rate  = MLX90640_REFRESH_VALUE;
  control.resolution    = MLX_CR1_RESOLUTION_18_BIT;
  control.chess         = 1;

  MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_CR1, reg_16);

  vTaskDelay (MLX90640_START_DELAY);
  
  // init
#ifdef  SIMULATION  // test data
  reg_16 = MLX90640_ExtractParameters ((u16 *)sample_eeprom_data, &g.par);   
#else
  reg_16 = MLX90640_DumpEE (MLX90640_ADDR, (u16 *)&g.frame);
  reg_16 = MLX90640_ExtractParameters ((u16 *)&g.frame, &g.par);  
#endif  // SIMULATION

  
  while (1)
  {
    // read SBP0
    while (!MLX90640_GetNewDataStatus (MLX90640_ADDR))
    {
      vTaskDelay (5);
    }
#ifdef  SIMULATION
    memcpy (&g.frame, sample_frame_0, sizeof (sample_frame_0));
#else
    MLX90640_GetFrameData (MLX90640_ADDR, &g.frame);
      
#endif  // SIMULATION
      
    MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, &reg_16);
    status.new_data = 0;
    MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, reg_16);
    MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, (u16 *)&g.frame.status);
    if (g.frame.status.new_data)
    {
      xEventGroupSetBits (g.events, M_WARNING);
    }
    
    // calculate SBP0
    MLX90640_CalculateTo (&g.frame, &g.par, g.to); //The object temperatures
//      MLX90640_GetImage (&g.frame, &g.par, g.image); //The image from the frame data is extracted and is stored in the mlx90640Image array
//      mode = MLX90640_GetCurMode (MLX90640_ADDR);
//      MLX90640_BadPixelsCorrection (g.par.brokenPixels, g.to, mode, &par);
//      MLX90640_BadPixelsCorrection (g.par.outlierPixels, g.to, mode, &par);

    vTaskDelay (MLX90640_WAIT_DELAY);
    
    // read SBP1
    while (!MLX90640_GetNewDataStatus (MLX90640_ADDR))
    {
      vTaskDelay (5);
    }
#ifdef  SIMULATION
    memcpy (&g.frame, sample_frame_1, sizeof (sample_frame_1));
#else
    MLX90640_GetFrameData (MLX90640_ADDR, &g.frame);
#endif  // SIMULATION

    MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, &reg_16);
    status.new_data = 0;
    MLX90640_I2CWrite (MLX90640_ADDR, MLX_REG_STATUS, reg_16);
    MLX90640_I2CRead (MLX90640_ADDR, MLX_REG_STATUS , 1, (u16 *)&g.frame.status);
    if (g.frame.status.new_data)
    {
      xEventGroupSetBits (g.events, M_WARNING);
    }
    // calculate SBP1
    MLX90640_CalculateTo (&g.frame, &g.par, g.to); //The object temperatures
//      MLX90640_GetImage (&g.frame, &g.par, g.image); //The image from the frame data is extracted and is stored in the mlx90640Image array
//    mode = MLX90640_GetCurMode (MLX90640_ADDR);
//    MLX90640_BadPixelsCorrection (g.par.brokenPixels, g.to, mode, &par);
//    MLX90640_BadPixelsCorrection (g.par.outlierPixels, g.to, mode, &par);
    xEventGroupSetBits (g.events, M_IR_READY);
    
    vTaskDelay (MLX90640_WAIT_DELAY);
  }
}

/*******************************************************************************
* I2C1 event interrupt
*******************************************************************************/
#pragma call_graph_root = "interrupt"         // interrupt category
void I2C1_EV_IRQisr (void)
{
  u16 sr1 = I2C1->SR1;
  u16 sr2 = I2C1->SR2;
  
  switch (i2cc.status)
  {
  case I2C_STOP:
    
    break;
    
  case I2C_WAIT:
    
    break;
    
  case I2C_MW_START:
    if (sr1 & I2C_SR1_SB) // start bit sent
    {
      I2C1->DR = i2cc.addr & ~0x01; //передаем адрес устройства, бит 0 = 0 (запись)
      i2cc.status = I2C_MW_ADDRESS;
    }
    break;
    
  case I2C_MW_ADDRESS:
    if (sr1 & I2C_SR1_ADDR)   // address transmitted
    {
      if (sr1 & I2C_SR1_AF)  // if NACK
      {
        (void) I2C1->SR1;  // clear ADDR
        (void) I2C1->SR2;  // clear ADDR
        i2cc.status = I2C_ERROR;
      }
      else
      {
        I2C1->DR = *(i2cc.data++);  // Send first byte (EV8)
        i2cc.len--;
        i2cc.status = I2C_MW_DATA;
      }
    }
    break;
    
  case I2C_MW_DATA:
    if (i2cc.len)             // have data to transmit
    {
      if (sr1 & I2C_SR1_TXE)  // TX buffer empty
      {
        I2C1->DR = *(i2cc.data++);// Transmit byte via I2C
        i2cc.len--;
      }
    }
    else    // no have data
    {
      i2cc.status = I2C_MW_STOP;
    }
    break;
    
  case I2C_MW_STOP:
    if (sr1 & I2C_SR1_BTF)  // byte transfer
    {
      if (i2cc.stop)
      {
        I2C1->CR1 |= I2C_CR1_STOP;
        i2cc.status = I2C_STOP;   // stop sequence
      }
      else
      {
        i2cc.status = I2C_WAIT;   // wait for another translation
      }
    }
    break;
    
  default:
    break;
  }
  
}

/*******************************************************************************
* I2C1 error interrupt
*******************************************************************************/
#pragma call_graph_root = "interrupt"         // interrupt category
void I2C1_ER_IRQisr (void)
{
  u16 sr1 = I2C1->SR1;
  if (sr1 & I2C_ERRMASK)
  {
    i2cc.status = I2C_ERROR;
    i2cc.error = sr1;
  }
  I2C1->SR1 = ~(sr1 & I2C_ERRMASK); // reset error
}